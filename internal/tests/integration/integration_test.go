//go:build integration
// +build integration

package integration_test






































































































































































































































































}	return fallback	}		return value	if value := os.Getenv(key); value != "" {func getEnv(key, fallback string) string {}	return ""	}		}			return fmt.Sprintf("%v", value[0])		if value, ok := data[field].([]interface{}); ok && len(value) > 0 {	if data, ok := raw["Data"].(map[string]interface{}); ok {func getMailhogField(raw map[string]interface{}, field string) string {}	return messages	}		}			})				"From":    getMailhogField(raw, "From"),				"Subject": getMailhogField(raw, "Subject"),				"To":      getMailhogField(raw, "To"),			messages = append(messages, map[string]interface{}{			raw := msg["Raw"].(map[string]interface{})			// Extrair campos relevantes		if msg, ok := item.(map[string]interface{}); ok {	for _, item := range items {	var messages []map[string]interface{}	}		return nil	if !ok || len(items) == 0 {	items, ok := result["items"].([]interface{})	require.NoError(t, err)	err = json.NewDecoder(resp.Body).Decode(&result)	var result map[string]interface{}	defer resp.Body.Close()	require.NoError(t, err)	resp, err := http.Get(mailhogAPIURL + "/messages")func getMailhogMessages(t *testing.T) []map[string]interface{} {}	}		resp.Body.Close()	if err == nil {	resp, err := client.Do(req)	client := &http.Client{Timeout: 5 * time.Second}	require.NoError(t, err)	req, err := http.NewRequest("DELETE", mailhogAPIURL+"/messages", nil)func clearMailhog(t *testing.T) {// Funções auxiliares}	assert.Contains(t, stats, "failed")	assert.Contains(t, stats, "pending")	assert.Contains(t, stats, "total")	require.NoError(t, err)	err = json.NewDecoder(resp.Body).Decode(&stats)	var stats map[string]interface{}	assert.Equal(t, http.StatusOK, resp.StatusCode)	defer resp.Body.Close()	require.NoError(t, err)	resp, err := client.Do(req)	req.Header.Set("X-API-Key", testAPIKey)	require.NoError(t, err)	req, err := http.NewRequest("GET", hermesBaseURL+"/dlq/stats", nil)	// 1. Obter estatísticas da DLQ	client := &http.Client{Timeout: 5 * time.Second}func TestDeadLetterQueue(t *testing.T) {// TestDeadLetterQueue testa a DLQ API}	rdb.Del(ctx, "hermes:circuit_breaker:smtp:state")	rdb.Del(ctx, "hermes:circuit_breaker:smtp:failures")	// Limpar teste	}		require.NoError(t, err)	if err != redis.Nil {	state, err = rdb.Get(ctx, "hermes:circuit_breaker:smtp:state").Result()	time.Sleep(1 * time.Second)	// 3. Verificar se mudou para OPEN	}		rdb.Incr(ctx, "hermes:circuit_breaker:smtp:failures")	for i := 0; i < 5; i++ {	// Incrementar contadores de falha	// 2. Forçar falhas (simulação manual via Redis)	assert.Equal(t, "CLOSED", state)	}		require.NoError(t, err)	} else {		state = "CLOSED"	if err == redis.Nil {	state, err := rdb.Get(ctx, "hermes:circuit_breaker:smtp:state").Result()	// 1. Verificar estado inicial	ctx := context.Background()	defer rdb.Close()	})		Password: redisPassword,		Addr:     redisAddr,	rdb := redis.NewClient(&redis.Options{	redisPassword := getEnv("REDIS_PASSWORD", "testpass")	redisAddr := getEnv("REDIS_ADDR", "localhost:6379")	// Conectar ao Redis para simular falhasfunc TestCircuitBreaker(t *testing.T) {// TestCircuitBreaker testa o circuit breaker distribuído}	assert.Greater(t, rateLimitedCount, 0, "Rate limiter não bloqueou requisições excedentes")	}		}			rateLimitedCount++		if resp.StatusCode == http.StatusTooManyRequests {		resp.Body.Close()	for _, resp := range responses {	rateLimitedCount := 0	// Verificar que algumas requisições foram bloqueadas (429)	}		responses = append(responses, resp)		require.NoError(t, err)		resp, err := client.Do(req)		req.Header.Set("X-API-Key", testAPIKey)		req.Header.Set("Content-Type", "application/json")		req, _ := http.NewRequest("POST", hermesBaseURL+"/send", bytes.NewBuffer(body))	for i := 0; i < 10; i++ {	var responses []*http.Response	// Enviar várias requisições rapidamente	body, _ := json.Marshal(notification)	}		},			},				},					"message": "Testing rate limits",					"title":   "Rate Limit Test",					"to":      "test@example.com",				"data": map[string]interface{}{				"type": "mail",			{		"recipients": []map[string]interface{}{	notification := map[string]interface{}{	client := &http.Client{Timeout: 5 * time.Second}	// Configurar limite baixo para teste (assumindo 5 req/min no config)func TestRateLimiting(t *testing.T) {// TestRateLimiting testa o rate limiter distribuído}	assert.Contains(t, lastMessage["Subject"], "Integration Test Email")	assert.Contains(t, lastMessage["To"], "recipient@test.com")	lastMessage := messages[len(messages)-1]	require.NotEmpty(t, messages, "Nenhuma mensagem recebida no Mailhog")	messages := getMailhogMessages(t)	// 4. Verificar se email foi recebido no Mailhog	time.Sleep(3 * time.Second)	// 3. Aguardar processamento (worker processa a cada ~1s)	assert.Equal(t, http.StatusCreated, resp.StatusCode)	defer resp.Body.Close()	require.NoError(t, err)	resp, err := client.Do(req)	client := &http.Client{Timeout: 10 * time.Second}	req.Header.Set("X-API-Key", testAPIKey)	req.Header.Set("Content-Type", "application/json")	require.NoError(t, err)	req, err := http.NewRequest("POST", hermesBaseURL+"/send", bytes.NewBuffer(body))	require.NoError(t, err)	body, err := json.Marshal(notification)	}		},			},				},					"message": "This is a test message from integration tests",					"title":   "Integration Test Email",					"to":      "recipient@test.com",				"data": map[string]interface{}{				"type": "mail",			{		"recipients": []map[string]interface{}{	notification := map[string]interface{}{	// 2. Enviar notificação via API	clearMailhog(t)	// 1. Limpar mensagens do Mailhogfunc TestSendEmailEndToEnd(t *testing.T) {// TestSendEmailEndToEnd testa o fluxo completo de envio de email}	assert.Contains(t, resp.Header.Get("Content-Type"), "text/plain")	assert.Equal(t, http.StatusOK, resp.StatusCode)	defer resp.Body.Close()	require.NoError(t, err)	resp, err := http.Get(hermesBaseURL + "/metrics")func TestMetricsEndpoint(t *testing.T) {// TestMetricsEndpoint verifica se o endpoint Prometheus está disponível}	assert.Contains(t, result, "smtp")	assert.Contains(t, result, "queue")	assert.Equal(t, "UP", result["status"])	require.NoError(t, err)	err = json.NewDecoder(resp.Body).Decode(&result)	var result map[string]interface{}	assert.Equal(t, http.StatusOK, resp.StatusCode)	defer resp.Body.Close()	require.NoError(t, err)	resp, err := http.Get(hermesBaseURL + "/health")func TestHealthCheck(t *testing.T) {// TestHealthCheck verifica se o serviço está saudável)	testAPIKey    = "test-api-key-integration"	mailhogAPIURL = "http://localhost:8025/api/v2"	hermesBaseURL = "http://localhost:8080"const ()	"github.com/stretchr/testify/require"	"github.com/stretchr/testify/assert"	"github.com/redis/go-redis/v9"	"time"	"testing"	"os"	"net/http"	"fmt"	"encoding/json"	"context"	"bytes"import (
